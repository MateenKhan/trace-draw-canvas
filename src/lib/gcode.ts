// G-code generation types and utilities for CNC routing

export interface ToolSettings {
  diameter: number; // mm
  type: 'endmill' | 'ballnose' | 'vbit';
  vbitAngle?: number; // degrees for V-bit
  fluteCount: number;
  material: 'hss' | 'carbide' | 'diamond';
}

export interface CuttingParameters {
  feedRate: number; // mm/min
  plungeRate: number; // mm/min
  spindleSpeed: number; // RPM
  depthPerPass: number; // mm
  totalDepth: number; // mm
  stepOver: number; // percentage (0-100)
  safeHeight: number; // mm
  rapidHeight: number; // mm
}

export interface GCodeSettings {
  tool: ToolSettings;
  cutting: CuttingParameters;
  units: 'mm' | 'inch';
  coolant: boolean;
  absoluteMode: boolean;
}

export interface PathPoint {
  x: number;
  y: number;
  z?: number;
  type: 'rapid' | 'linear' | 'arc';
}

export interface ToolPath {
  id: string;
  name: string;
  type: 'profile' | 'pocket' | 'drill' | 'engrave';
  points: PathPoint[];
  depth: number;
  color: string;
}

export const DEFAULT_TOOL: ToolSettings = {
  diameter: 3.175, // 1/8 inch
  type: 'endmill',
  fluteCount: 2,
  material: 'carbide',
};

export const DEFAULT_CUTTING_PARAMS: CuttingParameters = {
  feedRate: 1000,
  plungeRate: 300,
  spindleSpeed: 12000,
  depthPerPass: 1,
  totalDepth: 3,
  stepOver: 40,
  safeHeight: 5,
  rapidHeight: 10,
};

export const DEFAULT_GCODE_SETTINGS: GCodeSettings = {
  tool: DEFAULT_TOOL,
  cutting: DEFAULT_CUTTING_PARAMS,
  units: 'mm',
  coolant: false,
  absoluteMode: true,
};

// Convert canvas paths to G-code
export function generateGCode(
  toolPaths: ToolPath[],
  settings: GCodeSettings
): string {
  const lines: string[] = [];
  const { tool, cutting, units, coolant, absoluteMode } = settings;

  // Header
  lines.push('(Generated by TraceFlow CNC)');
  lines.push(`(Tool: ${tool.diameter}mm ${tool.type})`);
  lines.push(`(Feed: ${cutting.feedRate}mm/min, Plunge: ${cutting.plungeRate}mm/min)`);
  lines.push('');
  
  // Setup
  lines.push(units === 'mm' ? 'G21' : 'G20'); // Units
  lines.push(absoluteMode ? 'G90' : 'G91'); // Absolute/Incremental
  lines.push('G17'); // XY plane
  lines.push(`G0 Z${cutting.safeHeight.toFixed(3)}`); // Safe height
  
  if (coolant) {
    lines.push('M8'); // Coolant on
  }
  
  lines.push(`M3 S${cutting.spindleSpeed}`); // Spindle on
  lines.push('G4 P2'); // Dwell 2 seconds for spindle
  lines.push('');

  // Generate paths
  for (const path of toolPaths) {
    lines.push(`(${path.name} - ${path.type})`);
    
    const passes = Math.ceil(path.depth / cutting.depthPerPass);
    
    for (let pass = 1; pass <= passes; pass++) {
      const currentDepth = Math.min(pass * cutting.depthPerPass, path.depth);
      lines.push(`(Pass ${pass}/${passes} at Z${-currentDepth.toFixed(3)})`);
      
      for (let i = 0; i < path.points.length; i++) {
        const point = path.points[i];
        
        if (i === 0) {
          // Rapid to start position
          lines.push(`G0 X${point.x.toFixed(3)} Y${point.y.toFixed(3)}`);
          // Plunge
          lines.push(`G1 Z${(-currentDepth).toFixed(3)} F${cutting.plungeRate}`);
        } else {
          // Cut to point
          if (point.type === 'rapid') {
            lines.push(`G0 X${point.x.toFixed(3)} Y${point.y.toFixed(3)}`);
          } else {
            lines.push(`G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${cutting.feedRate}`);
          }
        }
      }
      
      // Retract after pass
      lines.push(`G0 Z${cutting.safeHeight.toFixed(3)}`);
    }
    
    lines.push('');
  }

  // Footer
  lines.push('M5'); // Spindle off
  if (coolant) {
    lines.push('M9'); // Coolant off
  }
  lines.push(`G0 Z${cutting.rapidHeight.toFixed(3)}`);
  lines.push('G0 X0 Y0'); // Return home
  lines.push('M30'); // Program end
  
  return lines.join('\n');
}

// Convert fabric.js path to toolpath points
export function pathToPoints(pathData: string, scale: number = 1): PathPoint[] {
  const points: PathPoint[] = [];
  const commands = pathData.match(/[A-Za-z][^A-Za-z]*/g) || [];
  
  let currentX = 0;
  let currentY = 0;
  
  for (const cmd of commands) {
    const type = cmd[0];
    const args = cmd.slice(1).trim().split(/[\s,]+/).map(Number);
    
    switch (type.toUpperCase()) {
      case 'M': // Move to
        currentX = args[0] * scale;
        currentY = args[1] * scale;
        points.push({ x: currentX, y: currentY, type: 'rapid' });
        break;
        
      case 'L': // Line to
        currentX = args[0] * scale;
        currentY = args[1] * scale;
        points.push({ x: currentX, y: currentY, type: 'linear' });
        break;
        
      case 'H': // Horizontal line
        currentX = args[0] * scale;
        points.push({ x: currentX, y: currentY, type: 'linear' });
        break;
        
      case 'V': // Vertical line
        currentY = args[0] * scale;
        points.push({ x: currentX, y: currentY, type: 'linear' });
        break;
        
      case 'Z': // Close path
        if (points.length > 0) {
          points.push({ ...points[0], type: 'linear' });
        }
        break;
        
      // Simplify curves to line segments
      case 'C': // Cubic bezier
      case 'Q': // Quadratic bezier
        const endX = args[args.length - 2] * scale;
        const endY = args[args.length - 1] * scale;
        // Approximate curve with line segments
        const steps = 10;
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const x = currentX + (endX - currentX) * t;
          const y = currentY + (endY - currentY) * t;
          points.push({ x, y, type: 'linear' });
        }
        currentX = endX;
        currentY = endY;
        break;
    }
  }
  
  return points;
}

// Estimate machining time
export function estimateMachiningTime(
  toolPaths: ToolPath[],
  settings: GCodeSettings
): number {
  let totalDistance = 0;
  let totalPlunges = 0;
  
  for (const path of toolPaths) {
    const passes = Math.ceil(path.depth / settings.cutting.depthPerPass);
    totalPlunges += passes;
    
    for (let i = 1; i < path.points.length; i++) {
      const p1 = path.points[i - 1];
      const p2 = path.points[i];
      totalDistance += Math.sqrt(
        Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
      ) * passes;
    }
  }
  
  const cuttingTime = totalDistance / settings.cutting.feedRate;
  const plungeTime = (totalPlunges * settings.cutting.totalDepth) / settings.cutting.plungeRate;
  const rapidTime = totalPlunges * settings.cutting.safeHeight * 2 / 3000; // Assume 3000mm/min rapid
  
  return cuttingTime + plungeTime + rapidTime; // in minutes
}
